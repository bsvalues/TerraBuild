/**
 * Badge Generation Script for BCBS Application
 * 
 * This script generates status badges for the README based on CI results,
 * test coverage, and other metrics.
 * 
 * Usage:
 *   node scripts/generate-badges.js [options]
 * 
 * Options:
 *   --output=dir  Output directory for badge images (default: badges)
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Parse command line arguments
const args = process.argv.slice(2).reduce((acc, arg) => {
  if (arg.includes('=')) {
    const [key, value] = arg.split('=');
    acc[key.replace('--', '')] = value;
  } else if (arg.startsWith('--')) {
    acc[arg.replace('--', '')] = true;
  }
  return acc;
}, {});

// Default configuration
const config = {
  output: args.output || 'badges',
};

// Ensure output directory exists
if (!fs.existsSync(config.output)) {
  fs.mkdirSync(config.output, { recursive: true });
}

/**
 * Generate badge SVG
 * @param {string} label Badge label
 * @param {string} message Badge message
 * @param {string} color Badge color
 * @returns {string} SVG content
 */
function generateBadgeSvg(label, message, color) {
  // Calculate widths
  const labelWidth = 10 + label.length * 6;
  const messageWidth = 10 + message.length * 6;
  const totalWidth = labelWidth + messageWidth;
  
  return `<svg xmlns="http://www.w3.org/2000/svg" width="${totalWidth}" height="20">
  <linearGradient id="b" x2="0" y2="100%">
    <stop offset="0" stop-color="#bbb" stop-opacity=".1"/>
    <stop offset="1" stop-opacity=".1"/>
  </linearGradient>
  <mask id="a">
    <rect width="${totalWidth}" height="20" rx="3" fill="#fff"/>
  </mask>
  <g mask="url(#a)">
    <path fill="#555" d="M0 0h${labelWidth}v20H0z"/>
    <path fill="${color}" d="M${labelWidth} 0h${messageWidth}v20H${labelWidth}z"/>
    <path fill="url(#b)" d="M0 0h${totalWidth}v20H0z"/>
  </g>
  <g fill="#fff" text-anchor="middle" font-family="DejaVu Sans,Verdana,Geneva,sans-serif" font-size="11">
    <text x="${labelWidth/2}" y="15" fill="#010101" fill-opacity=".3">${label}</text>
    <text x="${labelWidth/2}" y="14">${label}</text>
    <text x="${labelWidth + messageWidth/2}" y="15" fill="#010101" fill-opacity=".3">${message}</text>
    <text x="${labelWidth + messageWidth/2}" y="14">${message}</text>
  </g>
</svg>`;
}

/**
 * Save badge to file
 * @param {string} name Badge name
 * @param {string} svg SVG content
 */
function saveBadge(name, svg) {
  const filePath = path.join(config.output, `${name}.svg`);
  fs.writeFileSync(filePath, svg);
  console.log(`Generated badge: ${filePath}`);
}

/**
 * Get CI status for badge
 * @returns {Object} Status data
 */
function getCiStatus() {
  // In a real implementation, this would check GitHub Actions status
  // or retrieve status from CI system API
  
  try {
    // Mock data for illustration
    return {
      status: 'passing',
      color: '#4c1',
      branch: 'main',
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error('Error retrieving CI status:', error.message);
    return {
      status: 'unknown',
      color: '#9f9f9f',
      branch: 'main',
      timestamp: new Date().toISOString()
    };
  }
}

/**
 * Get test coverage for badge
 * @returns {Object} Coverage data
 */
function getTestCoverage() {
  // In a real implementation, this would read coverage reports
  // generated by Jest or other testing tools
  
  try {
    // Mock data for illustration
    return {
      coverage: 78,
      color: '#dfb317',
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error('Error retrieving test coverage:', error.message);
    return {
      coverage: 0,
      color: '#e05d44',
      timestamp: new Date().toISOString()
    };
  }
}

/**
 * Get documentation coverage for badge
 * @returns {Object} Documentation data
 */
function getDocCoverage() {
  // In a real implementation, this would analyze documentation
  // coverage from documentation tools
  
  try {
    // Mock data for illustration
    return {
      coverage: 85,
      color: '#4c1',
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    console.error('Error retrieving documentation coverage:', error.message);
    return {
      coverage: 0,
      color: '#e05d44',
      timestamp: new Date().toISOString()
    };
  }
}

/**
 * Generate Markdown for badges in README
 * @param {Object} data Badge data
 * @returns {string} Markdown content
 */
function generateMarkdown(data) {
  return `
## Project Status

[![CI Status](badges/ci.svg)](https://github.com/organization/bcbs/actions)
[![Test Coverage](badges/coverage.svg)](https://github.com/organization/bcbs/actions)
[![Documentation](badges/docs.svg)](https://github.com/organization/bcbs/docs)

*Last updated: ${new Date().toISOString().split('T')[0]}*
`;
}

// Main execution
try {
  console.log('Generating badges...');
  
  // Get status data
  const ciStatus = getCiStatus();
  const testCoverage = getTestCoverage();
  const docCoverage = getDocCoverage();
  
  // Generate badges
  saveBadge('ci', generateBadgeSvg('build', ciStatus.status, ciStatus.color));
  saveBadge('coverage', generateBadgeSvg('coverage', `${testCoverage.coverage}%`, testCoverage.color));
  saveBadge('docs', generateBadgeSvg('docs', `${docCoverage.coverage}%`, docCoverage.color));
  
  // Generate Markdown
  const markdown = generateMarkdown({
    ci: ciStatus,
    coverage: testCoverage,
    docs: docCoverage
  });
  
  console.log('\nMarkdown for README:');
  console.log(markdown);
  
  // Save Markdown to a file that can be included in README
  fs.writeFileSync('badges/status.md', markdown);
  console.log('\nStatus markdown saved to badges/status.md');
} catch (error) {
  console.error('Error generating badges:', error.message);
  process.exit(1);
}